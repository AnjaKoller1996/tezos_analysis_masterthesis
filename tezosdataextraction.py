# -*- coding: utf-8 -*-
"""TezosDataExtraction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-2_yoXTD55r4yiJ1Nx5hzIbOroyCITaV

see: https://tzstats.com/docs/api#accounts
"""

# import requests
import json
import requests
from pprint import pprint

"""**TODO**: create the following table only using tzstats
--> **Account, Rewards, Bakers, Blocks, Contracts, Cycles**

**Delegators/Delegates? reward split??**

**SQLite3 Database**(see: https://datatofish.com/)

1.   Connect your database name
2.   Create DB and Tables
3.   Import data using pandas


create-database-python-using-sqlite3/)
"""

# create a DB with sqlite3
import sqlite3
conn = sqlite3.connect('tezosdataextraction.db', timeout=10)
conn.isolation_level = None
c = conn.cursor() # db saved in location where .py file is save

"""# 1) Baker

"""

# Bakers
api_url_bakers = 'https://api.tzstats.com/explorer/bakers'
params = {'limit': 10000 }
r = requests.get(api_url_bakers, params = params)
baker_response = r.json()
# pprint(baker_response[0])

class Baker: 

  def __init__(self, address, id, total_balance, staking_balance, staking_capacity):
    self.address = address
    self.id = id
    self.total_balance = total_balance
    self.staking_balance = staking_balance
    self.staking_capacity = staking_capacity

# Create baker table
c.execute(''' SELECT count(name) FROM sqlite_master where type='table' AND name= 'bakers' ''')

if c.fetchone()[0]==1:
  c.execute('DROP TABLE bakers')
  c.execute('''CREATE TABLE bakers (address text, id integer, total_balance integer, staking_balance integer, staking_capacity integer)''')
else: 
  c.execute('''CREATE TABLE bakers (address text, id integer, total_balance integer, staking_balance integer, staking_capacity integer)''')

def insert_baker(baker):
  with conn: 
    c.execute('INSERT INTO bakers VALUES(:address, :id, :total_balance, :staking_balance, :staking_capacity)', {'address': baker.address, 'id': baker.id, 'total_balance': baker.total_balance, 'staking_balance': baker.staking_balance, 'staking_capacity': baker.staking_capacity})

# add all bakers to db
for baker in baker_response: 
  baker = Baker(baker['address'], baker['id'], baker['total_balance'], baker['staking_balance'], baker['staking_capacity'])
  insert_baker(baker)

conn.commit()

"""# 2) Accounts"""

# Accounts (get accounts by baker addresses)
api_url_accounts = 'https://api.tzstats.com/explorer/account/'

# Get all account bakers (rewards --> total_rewards_earned)
addresses = [r['address'] for r in baker_response]
account_response = []

for address in addresses: 
  r = requests.get(api_url_accounts + address)
  account_response.append(r.json())

num_account_baker_responses = len(account_response)
account_baker_rewards = [r['total_rewards_earned'] for r in account_response]
# print('first reward baker account', account_baker_rewards[0])

class Account: 

    def __init__(self, address, delegate, total_rewards_earned, total_fees_earned, total_lost, total_balance, staking_balance):
      self.address = address
      self.delegate = delegate
      self.total_rewards_earned = total_rewards_earned
      self.total_fees_earned = total_fees_earned # this here we are really interested in
      self.total_lost = total_lost
      self.total_balance = total_balance
      self.staking_balance = staking_balance

# Create accounts
c.execute(''' SELECT count(name) from sqlite_master where type='table' AND name='accounts' ''')

if c.fetchone()[0]==1:
  c.execute('DROP TABLE accounts')
  c.execute('''CREATE TABLE accounts (address text, delegate text, total_rewards_earned integer, total_fees_earned integer, total_lost integer, total_balance integer, staking_balance integer)''')
else: 
  c.execute('''CREATE TABLE accounts (address text, delegate text, total_rewards_earned integer, total_fees_earned integer, total_lost integer, total_balance integer, staking_balance integer)''')

def insert_acc(accbaker):
  with conn: 
    c.execute('INSERT INTO accounts VALUES(:address, :delegate, :total_rewards_earned, :total_fees_earned, :total_lost, :total_balance, :staking_balance)', {'address': accbaker.address, 'delegate': accbaker.delegate, 'total_rewards_earned': accbaker.total_rewards_earned, 'total_fees_earned': accbaker.total_fees_earned, 'total_lost': accbaker.total_lost, 'total_balance': accbaker.total_balance, 'staking_balance': accbaker.staking_balance})

# add all bakers to db
for accbak in account_response: 
  accbaker = Account(accbak['address'], accbak['delegate'], accbak['total_rewards_earned'], accbak['total_fees_earned'], accbak['total_lost'], accbak['total_balance'], accbak['staking_balance'])
  insert_acc(accbaker)

conn.commit()

"""# 3) Cycles

"""

# Cycles
api_url_cycles = 'https://api.tzstats.com/explorer/cycle/head'
r = requests.get(api_url_cycles)
cycles_response = r.json()
# print(len(cycles_response))
# pprint(cycles_response)

class Cycle: 

  def __init__(self, cycle, snapshot_index, active_bakers, active_delegators):
    self.cycle = cycle
    self.snapshot_index = snapshot_index
    self.active_bakers = active_bakers
    self.active_delegators = active_delegators

# Create cycles table: check if cycles table already exist
c.execute(''' SELECT count(name) FROM sqlite_master where type='table' AND name= 'cycles' ''')

# if count 1 then table already exist
if c.fetchone()[0]==1:
  c.execute('DROP TABLE cycles')
  c.execute('''CREATE TABLE cycles (cycle integer, snapshot_index integer, active_bakers integer, active_delegators integer)''')
else: 
  c.execute('''CREATE TABLE cycles (cycle integer, snapshot_index integer, active_bakers integer, active_delegators integer)''')

def insert_cycle(cycle):
  with conn:
    c.execute('INSERT INTO cycles VALUES(:cycle, :snapshot_index, :active_bakers, :active_delegators)', {'cycle': cycle['cycle'], 'snapshot_index': cycle['snapshot_index'], 'active_bakers': cycle['active_bakers'], 'active_delegators': cycle['active_delegators'] })

# add cycles to db
cycle = Cycle(cycles_response['cycle'], cycles_response['snapshot_index'],cycles_response['active_bakers'], cycles_response['active_delegators'])
insert_cycle(cycles_response)

conn.commit()

"""# 4) Contracts"""

# Contracts
api_url_contracts = 'https://api.tzstats.com/explorer/contracts/'
# get contract addresses from accounts where is_contract=True
contract_accounts = []
print(account_response[0]['is_contract'] == True)

for acc in account_response:
  if acc['is_contract'] == True: 
    contract_accounts.append(acc)

# contract_accounts = account_response['is_contract'] == True
print(contract_accounts)
if len(contract_accounts) > 0:
  contract_addresses = [r['address'] for r in contract_accounts]
  contracts_response = []
  for address in contract_addresses:
    r = requests.get(api_url_contracts + address)
    contracts_response.append(r.json())
  # pprint(contracts_response[0])

class Contract:

  def __init__(self, address, creator, delegate):
    self.address = address
    self.creator = creator
    self.delegate = delegate

# Create contracts
c.execute(''' SELECT count(name) from sqlite_master where type='table' AND name='contracts' ''')

if c.fetchone()[0]==1:
  c.execute('DROP TABLE contracts')
  c.execute('''CREATE TABLE contracts (address text, creator text, delegate text)''')
else: 
  c.execute('''CREATE TABLE contracts (address text, creator text, delegate text)''')

def insert_contract(contract):
  with conn: 
    c.execute('INSERT INTO contracts VALUES(:address, :creator, :delegate)', {'address': contract.address, 'creator': contract.creator, 'delegate': contract.delegate})

# add contract to db
if len(contract_accounts)>0:
  contract = Contract(contracts_response['address'], contracts_response['creator'], contracts_response['delegate'])
  insert_contract(contract)

conn.commit()

"""# 5) Analysis

We are interested in the **stakes** (the amount that somebody delegates to a baker) & rewards. See which **delegator** has how much reward --> therefore we extract delegator addresses from accounts (the ones that have the same address and delegate) & their total_fees_earned, total_rewards_earned, total_fees_paid
"""

# Delegates & their rewards and fees
delegators = []
for acc in account_response:
  if acc['is_delegate']:
    delegators.append(acc)

num_delegators = len(delegators)
print('Number of delegators',num_delegators)
# pprint(delegators[0])

class Delegator: 
  
  def __init__(self, address, total_rewards_earned, total_fees_earned, total_fees_paid):
    self.address = address
    self.total_rewards_earned = total_rewards_earned
    self.total_fees_earned = total_fees_earned
    self.total_fees_paid = total_fees_paid

# create a delegator table
c.execute(''' SELECT count(name) from sqlite_master where type='table' AND name='delegators' ''')

if c.fetchone()[0]==1:
  c.execute('DROP TABLE delegators')
  c.execute('''CREATE TABLE delegators (address text, total_rewards_earned text, total_fees_earned text, total_fees_paid text)''')
else: 
  c.execute('''CREATE TABLE delegators (address text, total_rewards_earned text, total_fees_earend text, total_fees_paid text)''')

def insert_delegator(delegator):
  with conn: 
    c.execute('INSERT INTO delegators VALUES(:address, :total_rewards_earned, :total_fees_earned, :total_fees_paid)', {'address': delegator.address, 'total_rewards_earned': delegator.total_rewards_earned, 'total_fees_earned': delegator.total_fees_earned, 'total_fees_paid': delegator.total_fees_paid})

# add contract to db
if len(delegators) > 0:
  for deleg in delegators:
    delegator = Delegator(deleg['total_rewards_earned'], deleg['total_fees_earned'], deleg['delegate'], deleg['total_fees_paid'])
    insert_delegator(delegator)

conn.commit()



"""TODO: get stakes for every cycle and reward for the respective delegator --> **How to find which delegator has how much reward in which cycle?**

Example look at 10 consecutive cycles and observe proportion of total tezos delegated by delegator -> do they get fair share? 

"""

# get a specific cycle
api_url_cycle_specific = 'https://api.tzstats.com/explorer/cycle/'
cycle_number = '247' # just a number can be any other number
r = requests.get(api_url_cycle_specific + cycle_number)
cycle_spec_response = r.json()
# pprint(cycle_spec_response)

# TODO: match with snapshot table, see: https://tzstats.com/docs/api#snapshot-table --> to get cycle information
# "https://api.tzstats.com/tables/snapshot?address=tz2TSvNTh2epDMhZHrw73nV9piBX7kLZ9K9m&cycle=150&is_selected=1&limit=1

snapshot_table_api_url = 'https://api.tzstats.com/tables/snapshot'
snapshots = []
# # TODO: do this for all addresses (delegator addresses)
addresses = [r['address'] for r in baker_response]
# addresses = ['tz2TSvNTh2epDMhZHrw73nV9piBX7kLZ9K9m']  # baker or delegator address of which we want the snapshot table

for address in addresses: 
  # if we want additionally add a cycle number specify here cycle number
  r = requests.get(snapshot_table_api_url+ '?address='+ address)
  snapshot_response = r.json()
  snapshots.append(snapshot_response)

pprint(snapshots[0][0][2])

class Snapshot: 
  def __init__(self, cycle, account_id, delegate_id, is_delegate, balance, delegated, address, delegate_address): 
    self.cycle = cycle
    self.account_id = account_id
    self.delegate_id = delegate_id
    self.is_delegate = is_delegate
    self.balance = balance
    self.delegated = delegated
    self.address = address
    self.delegate_address = delegate_address

# create a snapshot table
c.execute(''' SELECT count(name) from sqlite_master where type='table' AND name='snapshots' ''')

if c.fetchone()[0]==1:
  c.execute('DROP TABLE snapshots')
  c.execute('''CREATE TABLE snapshots (cycle integer, account_id integer, delegate_id integer, is_delegate boolean, balance integer, delegated boolean, address text, delegate_address text)''')
else: 
  c.execute('''CREATE TABLE snapshots (cycle integer, account_id integer, delegate_id integer, is_delegate boolean, balance integer, delegated boolean, address text, delegate_address text)''')

def insert_snapshot(snshot):
  with conn: 
    c.execute('INSERT INTO snapshots VALUES(:cycle, :account_id, :delegate_id, :is_delegate, :balance, :delegated, :address, :delegate_address)', {'cycle': snshot.cycle, 'account_id': snshot.account_id, 'delegate_id': snshot.delegate_id, 'is_delegate': snshot.is_delegate, 'balance': snshot.balance, 'delegated': snshot.delegated, 'address': snshot.address, 'delegate_address': snshot.delegate_address})

# snapshots is a list of snapshots (list of list)
# snapshots = snapshots[0]
# print('snapshots', snapshots)
print('cycle', snapshots[0][2])
print('account_id', snapshots[0][8])
if len(snapshots) > 0:
  for sn in snapshots:
    for snap in sn:
    # snapshot_response[0][2] -> cycle, [7] -> accound_id, [8] -> delegate_id, [9] -> is_delegate boolean, [10] -> balance, [11] -> delegated_amount, [15] -> address, [16] -> delegate_address, 
      snshot = Snapshot(snap[2], snap[7], snap[8], snap[9], snap[10], snap[11], snap[15], snap[16])
      insert_snapshot(snshot)

conn.commit()
print('snapshots done')

class Block: 

  def __init__(self, cycle, baker, fee, reward, deposit):
    self.cycle = cycle
    self.baker = baker
    self.fee = fee
    self.reward = reward
    self.deposit = deposit

url_template = 'https://api.tzstats.com/explorer/block/'
block_api_url = 'https://api.tzstats.com/explorer/block/head'
all_blocks = []
block = requests.get(block_api_url).json()
all_blocks.append(block)

# TODO: remove i<3 afterwards
# i=0
while block.get('predecessor', None) is not None:
# while (i < 3):
  predecessor_hash = block['predecessor']
  predecessor_block = requests.get(url_template + predecessor_hash).json()
  all_blocks.append(predecessor_block)
  block = predecessor_block
  # i +=1
  # print("blocks collected:", len(all_blocks))

# create blocks table
c.execute(''' SELECT count(name) from sqlite_master where type='table' AND name='blocks' ''')

if c.fetchone()[0]==1:
  c.execute('DROP TABLE blocks')
  c.execute('''CREATE TABLE blocks (cycle integer, baker text, fee real, reward real, deposit integer)''')
else: 
  c.execute('''CREATE TABLE blocks (cycle integer, baker text, fee real, reward real, deposit integer)''')

def insert_block(block):
  with conn: 
    c.execute('INSERT INTO blocks VALUES(:cycle, :baker, :fee, :reward, :deposit)', {'cycle': block.cycle, 'baker': block.baker, 'fee': block.fee, 'reward': block.reward, 'deposit': block.deposit})

if len(all_blocks) > 0:
  for bl in all_blocks:
    block = Block(bl['cycle'], bl['baker'], bl['fee'], bl['reward'], bl['deposit'])
    insert_block(block)

conn.commit()

# TODO: get all blocks by blocknumber that have the same cylce 
# see: https://api.tzstats.com/explorer/block/1342853 as an example where 1342853 is the block number

# TODO: out of the sanpshot table -> only take some cycles and observe for the same delegate_address the rewrad i.e. balance -> match the cycle and delegate info and get the respective reward from the delgator table

# all_blocks
# match all_blocks and snapshot_table on cycle & then get reward per delegator per cycle

